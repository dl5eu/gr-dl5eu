/* -*- c++ -*- */
/*
 * Copyright 2025 Ralf Gorholt.
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */

/*
 * ==============================================================
 *  This block is based on the block "ofdm_synchronization" that
 *  Federico La Rocca and others have developped for ISDB-T.
 * ==============================================================
 */

#include "dvbt_ofdm_synchronization_impl.h"
#include <gnuradio/io_signature.h>

namespace gr {
namespace dl5eu {

static const char* blockid = "dvbt_ofdm_synchronization";

namespace {
float calculate_rho(float snr)
{
    snr = pow(10, snr / 10.0);
    return snr / (snr + 1.0);
}
int get_num_carriers(dvbt_transmission_mode_t transmission_mode)
{
    int num_carriers = 0;

    switch (transmission_mode) {
    case T8k:
        num_carriers = 6817;
        break;
    case T2k:
    default:
        num_carriers = 1705;
        break;
    }

    return num_carriers;
}
} // namespace

using input_type = gr_complex;
using output_type = gr_complex;

void dvbt_ofdm_synchronization_impl::advance_freq_loop(float error)
{
    d_freq_aux = d_freq_aux + d_beta_freq * error;
    d_fine_freq = d_fine_freq + d_freq_aux + d_alpha_freq * error;
}

void dvbt_ofdm_synchronization_impl::advance_delta_loop(float error)
{
    d_delta_aux = d_delta_aux + d_beta_timing * error;
    d_est_delta = d_est_delta + d_delta_aux + d_alpha_timing * error;
}

int dvbt_ofdm_synchronization_impl::interpolate_input(const gr_complex* in,
                                                      gr_complex* out)
{
    int ii = 0; // Input index
    int oo = 0; // Output index
    double s;
    double f;
    int incr;

    while (oo < d_cp_length + d_fft_length) {
        out[oo++] = d_inter.interpolate(&in[ii], d_samp_phase);
        s = d_samp_phase + d_samp_inc;
        f = floor(s);
        incr = static_cast<int>(f);
        d_samp_phase = s - f;
        ii += incr;
    }

    // Tell the caller how many input values we needed to generate d_cp_length +
    // d_fft_length output values
    return ii;
}

void dvbt_ofdm_synchronization_impl::estimate_fine_synchro(gr_complex* current_channel,
                                                           gr_complex* previous_channel)
{
    gr_complex result_1st = gr_complex(0.0, 0.0);
    volk_32fc_x2_conjugate_dot_prod_32fc(&result_1st,
                                         &current_channel[0],
                                         &previous_channel[0],
                                         floor(d_num_carriers / 2.0));
    gr_complex result_2nd = gr_complex(0.0, 0.0);
    int low = static_cast<int>(floor(d_num_carriers / 2.0));
    volk_32fc_x2_conjugate_dot_prod_32fc(
        &result_2nd, &current_channel[low], &previous_channel[low], d_num_carriers - low);
    float delta_est_error = 1.0 / (1.0 + static_cast<float>(d_cp_length) / d_fft_length) /
                            (2.0 * static_cast<float>(GR_M_PI) * d_num_carriers / 2.0) *
                            std::arg(result_2nd * std::conj(result_1st));
    float freq_est_error = (std::arg(result_1st) + std::arg(result_2nd)) / 2.0 /
                           (1.0 + static_cast<float>(d_cp_length) / d_fft_length);

    // If for any reason the CP position has changed, the signal error is wrong
    // and should not be fed into the loop.
    if (!d_cp_moved) {
        advance_delta_loop(delta_est_error);
        advance_freq_loop(freq_est_error);
    }

    d_samp_inc = 1.0 - d_est_delta;
}

void dvbt_ofdm_synchronization_impl::send_symbol_index_and_resync(int current_offset)
{
    int diff = d_current_symbol - d_previous_symbol;
    // If there is any symbol lost no longer print stuff
    if (diff != 1 && diff != -3) {
        // If a symbol skip is detected, we should signal it downstream
        const uint64_t offset = this->nitems_written(0) + current_offset;
        pmt::pmt_t key = pmt::string_to_symbol("resync");
        pmt::pmt_t value =
            pmt::string_to_symbol("generated by sync and channel estimation");
        pmt::pmt_t srcid = pmt::string_to_symbol(blockid);
        this->add_item_tag(0, offset, key, value, srcid);

        d_symbol_correct_count = 0;
    } else {
        ++d_symbol_correct_count;
    }

    // If nothing weird happens for 3 consecutive times, assume
    // the symbol was correctly acquired
    d_symbol_acq = d_symbol_correct_count > 3;

    // Signal downstream the relative symbol index found here.
    const uint64_t offset = this->nitems_written(0) + current_offset;
    pmt::pmt_t key = pmt::string_to_symbol("relative_symbol_index");
    pmt::pmt_t value = pmt::from_long(d_current_symbol);
    pmt::pmt_t srcid = pmt::string_to_symbol(blockid);
    this->add_item_tag(0, offset, key, value, srcid);
}

void dvbt_ofdm_synchronization_impl::linearly_estimate_channel_taps(
    int current_symbol, gr_complex* channel_gain)
{
    // This method interpolates scattered measurements across one OFDM symbol
    // It does not use measurements from the previous OFDM symbols (does not use history)
    // as it may have encountered a phase change for the current phase only
    // TODO: interpolation is too simple, a new method(s) should be implemented

    // Current SP carrier
    int current_sp_carrier = 3 * current_symbol;
    // Next SP carrier
    int next_sp_carrier = 12 + 3 * current_symbol;
    for (int i = 0; i < d_num_spilots - 1; ++i) {
#if VOLK_VERSION >= 030100
        volk_32fc_s32fc_multiply2_32fc(&d_aux_linear_estimate_first[0],
                                       &d_coeffs_linear_estimate_first[0],
                                       &channel_gain[current_sp_carrier],
                                       11);
        volk_32fc_s32fc_multiply2_32fc(&d_aux_linear_estimate_last[0],
                                       &d_coeffs_linear_estimate_last[0],
                                       &channel_gain[next_sp_carrier],
                                       11);
#else
        volk_32fc_s32fc_multiply_32fc(&d_aux_linear_estimate_first[0],
                                      &d_coeffs_linear_estimate_first[0],
                                      channel_gain[current_sp_carrier],
                                      11);
        volk_32fc_s32fc_multiply_32fc(&d_aux_linear_estimate_last[0],
                                      &d_coeffs_linear_estimate_last[0],
                                      channel_gain[next_sp_carrier],
                                      11);
#endif
        for (int j = 1; j < 12; ++j) {
            channel_gain[current_sp_carrier + j] =
                d_aux_linear_estimate_first[j - 1] + d_aux_linear_estimate_last[j - 1];
        }
        current_sp_carrier += 12;
        next_sp_carrier += 12;
    }
    ////////////////////////////////////////////////////////////////
    // Take care of extreme cases: first carriers and last carriers
    ////////////////////////////////////////////////////////////////
    // I did not optimize this part since they're only a few carriers

    gr_complex tg_alpha;
    if (current_symbol > 0) {
        // We have not updated the gain on the first carriers
        // We now do this with a very simple linear interpolator
        // TODO: is this a good estimation?
        current_sp_carrier = 3 * current_symbol;
        next_sp_carrier = 12 + 3 * current_symbol;
        tg_alpha = (channel_gain[next_sp_carrier] - channel_gain[current_sp_carrier]) /
                   gr_complex(next_sp_carrier - current_sp_carrier, 0.0);
        // Calculate interpolation for all intermediate values
        for (int j = -current_sp_carrier; j < 0; ++j) {
            channel_gain[current_sp_carrier + j] =
                channel_gain[current_sp_carrier] + tg_alpha * gr_complex(j, 0.0);
        }
    }

    // Now the other extreme case: the last carriers.
    // We will use the last SP and the CP
    current_sp_carrier = 12 * (d_num_spilots - 1) + 3 * current_symbol;
    next_sp_carrier = d_num_carriers - 1;
    float delta_carriers = (float)next_sp_carrier - current_sp_carrier;
    for (int j = 1; j < delta_carriers; ++j) {
        channel_gain[current_sp_carrier + j] =
            channel_gain[current_sp_carrier] * gr_complex(1.0 - j / delta_carriers, 0.0) +
            channel_gain[next_sp_carrier] * gr_complex(j / delta_carriers, 0.0);
    }
}

void dvbt_ofdm_synchronization_impl::calculate_channel_taps_sp(const gr_complex* in,
                                                               int current_symbol,
                                                               gr_complex* channel_gain)
{
    // We first calculate the channel gain on the SP carriers.
    // We get each SP carrier position. We now know which is the current symbol (0, 1, 2
    // or 3)
    for (int current_sp_carrier = 3 * current_symbol;
         current_sp_carrier < d_num_carriers - 1;
         current_sp_carrier += 12) {
        channel_gain[current_sp_carrier] =
            in[current_sp_carrier] / d_pilot_values[current_sp_carrier];
    }
    // We then calculate the gain on the last CP
    channel_gain[d_num_carriers - 1] =
        in[d_num_carriers - 1] / d_pilot_values[d_num_carriers - 1];
}

int dvbt_ofdm_synchronization_impl::estimate_symbol_index(const gr_complex* in)
{
    /*************************************************************/
    // Find out the OFDM symbol index (value 0 to 3) sent in the
    // current block by correlating scattered pilots with the
    // current block - result is (symbol index % 4)
    /*************************************************************/
    float max = 0;
    gr_complex sum = 0;
    int symbol_index = 0;

    int current_sp_carrier; // The current SP carrier
    // sym_count (Symbol count) can take values from 0 to 3, according to the positions of
    // the scattered pilots
    for (int sym_count = 0; sym_count < 4; ++sym_count) {
        sum = 0;
        // The position of the next and current SP carrier based on the value of sym_count
        // For every scattered pilot but the last one...
        for (int next_sp_carrier = 12 + 3 * sym_count;
             next_sp_carrier < d_num_carriers - 1;
             next_sp_carrier += 12) {
            current_sp_carrier = next_sp_carrier - 12;
            if (d_pilot_values[next_sp_carrier] == d_pilot_values[current_sp_carrier]) {
                // If the phase difference between in[next_sp_carrier] and
                // in[current_sp_carrier] is zero, this is because we expect both to be
                // always in phase
                sum += in[next_sp_carrier] * conj(in[current_sp_carrier]);
            } else {
                // If the phase difference between in[next_sp_carrier] and
                // in[current_sp_carrier] is not zero, this is because we expect both to
                // be always out of phase by 180 degrees
                sum -= in[next_sp_carrier] * conj(in[current_sp_carrier]);
            }

            // sum +=
            // d_pilot_values[next_sp_carrier]*d_pilot_values[current_sp_carrier]*in[next_sp_carrier]*conj(in[current_sp_carrier]);
        }
        d_corr_sp[sym_count] = abs(sum);
        if (abs(sum) > max) {
            // When sum is maximum sym_count contains the current symbol (0, 1, 2 or 3)
            max = abs(sum);
            symbol_index = sym_count;
        }
    }
    return symbol_index;
}

void dvbt_ofdm_synchronization_impl::generate_prbs()
{
    // Generate the PRBS sequence for each active carrier.
    // This is actually done by the pilot generator object.
    for (int k = 0; k < d_num_carriers; ++k) {
        d_pilot_values[k] =
            gr_complex((float)(4 * 2 * (0.5 - d_pg.pilot_values()[k])) / 3, 0);
    }
    // printf("d_pilot_value[%i]: %f\n", d_num_carriers-1,
    //        d_pilot_values[d_num_carriers-1].real());
}

int dvbt_ofdm_synchronization_impl::estimate_integer_freq_offset(const gr_complex* in)
{
    // Look for maximum correlation for cpilots in order to obtain post-FFT integer
    // frequency correction
    //
    // TODO: use the channel taps in the correlation??
    float max = 0;
    gr_complex sum = 0;
    int start = 0;

    // for d_zeros_on_left +/- d_freq_offset_max...
    for (int i = d_zeros_on_left - d_freq_offset_max;
         i < d_zeros_on_left + d_freq_offset_max;
         ++i) {
        sum = 0;
        for (int j = 0; j < d_num_cpilots - 1; ++j) {
            if (d_known_phase_diff[j] == 0) {
                // If the phase difference between d_cpilot_carriers[j + 1] and
                // d_cpilot_carriers[j] is zero, this is because we expect both
                // to be always in phase
                sum += in[i + d_cpilots[j + 1]] * conj(in[i + d_cpilots[j]]);
            } else {
                // If the phase difference between d_cpilot_carriers[j + 1] and
                // d_cpilot_carriers[j] is not zero, this is because we expect
                // both to be always out of phase by 180 degrees
                sum -= in[i + d_cpilots[j + 1]] * conj(in[i + d_cpilots[j]]);
            }
        }
        if (abs(sum) > max) {
            // When sum is maximum, 'i' contains the first active carrier
            max = abs(sum);
            start = i;
        }
    }

    // Count how many times it has consistently pointed to a new frequency offset.
    // I will call this function only when I've this is less than a certain threshold
    // In 1-seg or 2k-mode, correlation sometimes fails.
    // Doesthis apply to DVB-T?
    int new_freq_offset = start - d_zeros_on_left;

    if (new_freq_offset == 0) {
        ++d_freq_offset_agree_count;
    } else {
        d_freq_offset_agree_count = 0;
    }

    // If I got 0 integer offset several consecutive
    // times I assume it's been acquired.
    d_freq_offset_acq = d_freq_offset_agree_count > 3;

    // We get the integer frequency offset
    return new_freq_offset;
}

void dvbt_ofdm_synchronization_impl::calculate_fft(gr_complex* out)
{
    // We assume that the input data have already been copied into the calculator's buffer
    // memcpy(d_fft_calculator.get_inbuf(), in, sizeof(gr_complex)*d_fft_length);
    // Calculate the FFT
    d_fft_calculator.execute();

    // We have to perform an FFT shift
    unsigned int len = (unsigned int)(ceil(d_fft_length / 2.0));
    memcpy(&out[0],
           &d_fft_calculator.get_outbuf()[len],
           sizeof(gr_complex) * (d_fft_length - len));
    memcpy(&out[d_fft_length - len],
           &(d_fft_calculator.get_outbuf()[0]),
           sizeof(gr_complex) * len);
}

bool dvbt_ofdm_synchronization_impl::ml_sync(const gr_complex* in,
                                             int lookup_start,
                                             int lookup_stop,
                                             int* cp_pos,
                                             float* peak_epsilon)
{
    assert(lookup_start >= lookup_stop);
    assert(lookup_stop >= (d_cp_length + d_fft_length - 1));

    int low, size;

    // Calculate norm
    low = lookup_stop - (d_cp_length + d_fft_length - 1);
    size = lookup_start - low + 1;

    volk_32fc_magnitude_squared_32f(&d_norm[low], &in[low], size);

    // Calculate gamma on each point
    // TODO: check these boundaries!!!!!!!
    low = lookup_stop - (d_cp_length - 1);
    size = lookup_start - low + 1;

    volk_32fc_x2_multiply_conjugate_32fc(
        &d_corr[low - d_fft_length], &in[low], &in[low - d_fft_length], size);

    // Calculate time delay and frequency correction
    float sum_aux = 0;
    for (int i = lookup_start - 1; i >= lookup_stop; --i) {
        int k = i - lookup_stop;
        // No accumulator for complexes in VOLK for the moment (exists since April 2021,
        // change lines when widespread).
        volk_32fc_32f_dot_prod_32fc(&d_gamma[k],
                                    &d_corr[i - d_cp_length + 1 - d_fft_length],
                                    &d_ones[0],
                                    d_cp_length);
        // volk_32fc_accumulator_s32fc(
        //     &d_gamma[k], &d_corr[i - d_cp_length + 1 - d_fft_length], d_cp_length);
        volk_32f_accumulator_s32f(&d_phi[k], &d_norm[i - d_cp_length + 1], d_cp_length);
        volk_32f_accumulator_s32f(
            &sum_aux, &d_norm[i - d_cp_length + 1 - d_fft_length], d_cp_length);
        d_phi[k] += sum_aux;
    }

    // Init lambda with gamma
    low = 0;
    size = lookup_start - lookup_stop;
    volk_32fc_magnitude_32f(&d_lambda[low], &d_gamma[low], size);

    // Calculate lambda
    low = 0;
    size = lookup_start - lookup_stop;
    volk_32f_s32f_multiply_32f(&d_phi[low], &d_phi[low], d_rho / 2.0, size);
    volk_32f_x2_subtract_32f(&d_lambda[low], &d_lambda[low], &d_phi[low], size);

    int peak = 0;
    bool peak_found = true;

    // Find peaks of lambda
    // We have found an end of symbol at peak_pos[0] + CP + FFT
    if ((peak_found =
             detect_peak_position(&d_lambda[0], (lookup_start - lookup_stop), &peak))) {
        *cp_pos = peak + lookup_stop;

        // Calculate frequency correction
        *peak_epsilon = fast_atan2f(d_gamma[peak]);
    }

    return peak_found;
}

void dvbt_ofdm_synchronization_impl::init_peak_detection(float threshold_factor_rise,
                                                         float alpha)
{
    d_avg_alpha = alpha;
    d_threshold_factor_rise = threshold_factor_rise;
    d_avg_max = std::numeric_limits<float>::min();
    d_avg_min = std::numeric_limits<float>::max();
}

bool dvbt_ofdm_synchronization_impl::detect_peak_position(const float* data,
                                                          const int data_size,
                                                          int* peak_pos)
{
    uint16_t peak_index = 0;
    uint32_t d_data_size = static_cast<uint32_t>(data_size);
    bool success = true;

    // Find the maximum value in the given data vector
    volk_32f_index_max_16u(&peak_index, &data[0], d_data_size);

    if (data_size >= d_fft_length) {
        float min = data[(peak_index + d_fft_length / 2) % d_fft_length];
        if (d_avg_min == static_cast<float>(INFINITY)) {
            d_avg_min = min;
        } else {
            d_avg_min = d_avg_alpha * min + (1 - d_avg_alpha) * d_avg_min;
        }
    }

    if (d_avg_max == static_cast<float>(-INFINITY)) {
        // Initialize d_avg_max with the first value.
        d_avg_max = data[peak_index];
    } else if (data[peak_index] >
               d_avg_max - d_threshold_factor_rise * (d_avg_max - d_avg_min)) {
        d_avg_max = d_avg_alpha * data[peak_index] + (1 - d_avg_alpha) * d_avg_max;
    } else {
        success = false;
        // printf("OFDM Synchronization: peak under/over average! peak %f, avg_max %f,
        // avg_min %f\n",
        //        data[ peak_index ], d_avg_max, d_avg_min);
    }

    // We now check whether the peak is in the border of the search interval. This would
    // mean that the search interval is not correct, and it should be reset. This happens
    // for instance when the hardware dropped some samples. Our definition of "border of
    // the search interval" depends if the search interval is "big" or not.
    if (data_size < d_fft_length) {
        if ((peak_index == 0) || (peak_index == data_size - 1)) {
            success = false;
            // printf("OFDM Synchronization: peak at border! peak %f, avg_max %f, avg_min
            // %f, peak_index: %i\n",
            //        data[ peak_index ], d_avg_max, d_avg_min, peak_index);
        }
    } else {
        if ((peak_index < 5) || (peak_index > data_size - 5)) {
            success = false;
            // printf("OFDM Synchronization: peak at border! peak %f, avg_max %f, avg_min
            // %f, peak_index: %i\n",
            //        data[ peak_index ], d_avg_max, d_avg_min, peak_index);
        }
    }

    *peak_pos = peak_index;

    return success;
}

void dvbt_ofdm_synchronization_impl::send_sync_start()
{
    const uint64_t offset = this->nitems_written(0);
    pmt::pmt_t key = pmt::string_to_symbol("sync_start");
    pmt::pmt_t value = pmt::from_long(1);
    pmt::pmt_t srcid = pmt::string_to_symbol("dvbt_ofdm_synchronization");
    this->add_item_tag(0, offset, key, value, srcid);
}

// Derotates the signal
void dvbt_ofdm_synchronization_impl::derotate(const gr_complex* in, gr_complex* out)
{
    double sensitivity = (double)(-1) / (double)d_fft_length;
    d_phaseinc = sensitivity * d_total_freq_error;

    gr_complex phase_increment = gr_complex(std::cos(d_phaseinc), std::sin(d_phaseinc));
    gr_complex phase_current = gr_complex(std::cos(d_phase), std::sin(d_phase));

#if VOLK_VERSION >= 030100
    volk_32fc_s32fc_x2_rotator2_32fc(
        &out[0], &in[0], &phase_increment, &phase_current, d_fft_length);
#else
    volk_32fc_s32fc_x2_rotator_32fc(
        &out[0], &in[0], phase_increment, &phase_current, d_fft_length);
#endif
    d_phase = std::arg(phase_current);
    d_phase = fmod(d_phase + d_phaseinc * d_cp_length, (float)2 * M_PI);
}


dvbt_ofdm_synchronization::sptr
dvbt_ofdm_synchronization::make(dvbt_transmission_mode_t transmission_mode,
                                dvb_guardinterval_t guard_interval,
                                float snr,
                                bool interpolate)
{
    return gnuradio::make_block_sptr<dvbt_ofdm_synchronization_impl>(
        transmission_mode, guard_interval, snr, interpolate);
}

/*
 * The private constructor
 */
dvbt_ofdm_synchronization_impl::dvbt_ofdm_synchronization_impl(
    dvbt_transmission_mode_t transmission_mode,
    dvb_guardinterval_t guard_interval,
    float snr,
    bool interpolate)
    : gr::block("dvbt_ofdm_synchronization",
                gr::io_signature::make(1, 1, sizeof(input_type)),
                gr::io_signature::make3(
                    1,
                    4,
                    sizeof(output_type) * get_num_carriers(transmission_mode),
                    sizeof(output_type) * get_num_carriers(transmission_mode),
                    sizeof(float))),
      d_config(dtv::MOD_16QAM,
               dtv::NH,
               dtv::C1_2,
               dtv::C1_2,
               guard_interval,
               transmission_mode),
      d_pg(d_config),

      d_num_carriers{ d_config.d_Kmax - d_config.d_Kmin + 1 },
      d_num_cpilots{ d_pg.cpilot_carriers_size() },
      d_num_spilots{ d_pg.spilot_carriers_size() },
      d_cpilots{ d_pg.cpilot_carriers() },

      d_fft_length{ d_config.d_fft_length },
      d_cp_length{ d_config.d_cp_length },

      d_cp_start{ 0 },
      d_cp_found{ 0 },
      d_gamma(d_fft_length + d_cp_length),
      d_phi(d_fft_length),
      d_lambda(d_fft_length),
      d_coarse_freq{ 0.0 },
      d_derot(d_fft_length + d_cp_length),
      d_conj(2 * d_fft_length + d_cp_length),
      d_norm(2 * d_fft_length + d_cp_length),
      d_corr(2 * d_fft_length + d_cp_length),

      d_snr{ snr },
      d_rho{ calculate_rho(d_snr) },

      d_threshold_factor_rise{ 0.0 },
      d_avg_alpha{ 0.0 },
      d_avg_min{ 0.0 },
      d_avg_max{ 0.0 },

      d_phaseinc{ 0.0 },
      d_nextphaseinc{ 0.0 },
      d_nextpos{ 0 },
      d_phase{ 0.0 },

      d_initial_acquired{ false },

      d_postfft(d_fft_length),
      d_fft_calculator(d_fft_length),

      // Integer frequency correction part
      d_zeros_on_left{ d_config.d_zeros_on_left },
      d_freq_offset_max{ 10 },
      d_freq_offset{ 0 },
      d_freq_offset_agree_count{ 0 },
      d_freq_offset_acq{ false },

      d_known_phase_diff(d_num_cpilots),
      d_integer_freq_derotated{ nullptr },

      d_pilot_values(d_num_carriers),
      d_channel_gain(d_num_carriers),
      d_coeffs_linear_estimate_first(11), // TODO: Check size!
      d_aux_linear_estimate_first(11),    // TODO: Check size!
      d_coeffs_linear_estimate_last(11),  // TODO: Check size!
      d_aux_linear_estimate_last(11),     // TODO: Check size!
      d_channel_gain_mag_sq(d_num_carriers),
      d_ones(d_num_carriers),
      d_channel_gain_inv(d_num_carriers),

      d_current_symbol{ 0 },
      d_previous_symbol{ 0 },
      d_symbol_acq{ false },
      d_symbol_correct_count{ 0 },
      d_corr_sp(4), // TODO: Check size!

      d_previous_channel_gain(d_num_carriers),
      d_delta_channel_gains(d_num_carriers),
      d_interpolate{ interpolate },
      d_interpolated(d_fft_length + d_cp_length),
      d_inter{ gr::filter::mmse_fir_interpolator_cc() },
      d_samp_inc{ 1.0 },
      d_samp_phase{ 0.0 },
      d_cp_start_offset{ -10 },

      d_alpha_freq{ 0.0 },
      d_beta_freq{ 0.0 },
      d_alpha_timing{ 0.0 },
      d_beta_timing{ 0.0 },
      d_freq_aux{ 0.0 },
      d_fine_freq{ 0.0 },
      d_delta_aux{ 0.0 },
      d_est_delta{ 0.0 },
      d_cp_moved{ true },

      d_total_freq_error{ 0.0 }
{
    set_relative_rate(1.0 / static_cast<double>(d_cp_length + d_fft_length));

    init_peak_detection(0.3, 0.9);

    generate_prbs();

    // Obtain phase diff for all continual pilots
    // TODO: eliminate d_known_phase_diff
    for (int i = 0; i < (d_num_cpilots - 1); ++i) {
        d_known_phase_diff[i] =
            std::norm(d_pilot_values[d_cpilots[i + 1]] - d_pilot_values[d_cpilots[i]]);
    }

    for (int i = 0; i < 4; ++i) {
        d_corr_sp[i] = 0.0;
    }

    for (int i = 0; i < d_num_carriers; ++i) {
        d_ones[i] = 1.0;
    }

    for (int i = 1; i < 12; ++i) {
        d_coeffs_linear_estimate_first[i - 1] = gr_complex(1.0 - i / 12.0, 0.0);
        d_coeffs_linear_estimate_last[i - 1] = gr_complex(i / 12.0, 0.0);
    }

    float loop_bw_freq = GR_M_PI / 100;
    float loop_bw_timing = GR_M_PI / 10000;
    float damping = sqrtf(2.0f) / 2.0f;
    float denom = (1.0 + 2.0 * damping * loop_bw_freq + loop_bw_freq * loop_bw_freq);
    d_beta_freq = (4 * loop_bw_freq * loop_bw_freq) / denom;
    d_alpha_freq = (4 * damping * loop_bw_freq) / denom;
    denom = (1.0 + 2.0 * damping * loop_bw_timing + loop_bw_timing * loop_bw_timing);
    d_beta_timing = (4 * loop_bw_timing * loop_bw_timing) / denom;
    d_alpha_timing = (4 * damping * loop_bw_timing) / denom;
    d_freq_aux = 0;
    d_fine_freq = 0;
    d_total_freq_error = 0;
}

/*
 * Our virtual destructor.
 */
dvbt_ofdm_synchronization_impl::~dvbt_ofdm_synchronization_impl() {}

void dvbt_ofdm_synchronization_impl::forecast(int noutput_items,
                                              gr_vector_int& ninput_items_required)
{
    // Make sure that we receive at least (cp_length + fft_length) items
    int ninputs = ninput_items_required.size();
    for (int i = 0; i < ninputs; ++i) {
        ninput_items_required[i] = static_cast<int>(
            ceil((d_cp_length + d_fft_length) * (noutput_items + 1) * d_samp_inc) +
            d_inter.ntaps());
    }
}

int dvbt_ofdm_synchronization_impl::general_work(int noutput_items,
                                                 gr_vector_int& ninput_items,
                                                 gr_vector_const_void_star& input_items,
                                                 gr_vector_void_star& output_items)
{
    auto in = static_cast<const input_type*>(input_items[0]);
    auto out = static_cast<output_type*>(output_items[0]);

    bool ch_output_connected = output_items.size() >= 2;
    bool freq_error_output_connected = output_items.size() >= 3;
    bool samp_error_output_connected = output_items.size() >= 4;

    output_type* out_channel_gain;
    float* out_freq_error;
    float* out_samp_error;
    if (ch_output_connected) {
        out_channel_gain = static_cast<output_type*>(output_items[1]);
    }
    if (freq_error_output_connected) {
        out_freq_error = static_cast<float*>(output_items[2]);
    }
    if (samp_error_output_connected) {
        out_samp_error = static_cast<float*>(output_items[3]);
    }

    d_consumed = 0;
    d_to_output = 0;

    for (int i = 0; i < noutput_items; ++i) {
        int required_for_interpolation = d_fft_length + d_cp_length;

        if (!d_initial_acquired) {
            // If we are here this means that we have no idea where the CP may be. We thus
            // search it thoroughly. We also perform a coarse frequency estimation.
            d_initial_acquired = ml_sync(&in[d_consumed],
                                         2 * d_fft_length + d_cp_length - 1,
                                         d_fft_length + d_cp_length - 1,
                                         &d_cp_start,
                                         &d_coarse_freq);
            d_cp_found = d_initial_acquired;

            // The interpolation should be restarted too (not the correcting factor,
            // which should not have changed, only the phase of the interpolator)
            d_samp_phase = 0;

            // CP position may have changed
            d_cp_moved = true;

            // We also have not the least idea of how many samples we dropped, and thus
            // in which symbol we are.
            d_symbol_acq = false;

            // TODO is necessary to re-calculate the integer frequency?
            d_freq_offset_acq = false;
        } else {
            // If we are here it means that in the previous iteration we found the CP. We
            // now thus only search near it. In fact, we use this only to check whether
            // the CP is still present (it may well happen that the USRP drops samples in
            // which case the peak in the correlation is not present). We thus do not use
            // the corresponding estimates of frequency and CP position.
            int cp_start_temp;
            float coarse_freq_temp;
            d_cp_found = ml_sync(&in[d_consumed],
                                 d_cp_start + 8,
                                 std::max(d_cp_start - 8, d_cp_length + d_fft_length - 1),
                                 &cp_start_temp,
                                 &coarse_freq_temp);

            if (!d_cp_found) {
                // We may have not found the CP because the smaller search range was too
                // small (rare, but possible, in particular when sampling time error are
                // present). We thus retry with a bigger search range and update
                // d_cp_start.
                d_cp_found =
                    ml_sync(&in[d_consumed],
                            d_cp_start + 16,
                            std::max(d_cp_start - 16, d_cp_length + d_fft_length - 1),
                            &d_cp_start,
                            &coarse_freq_temp);

                // Since I'm moving the position, the interpolator's phase should be
                // restarted too
                d_samp_phase = 0;

                // Indicate that the CP may have moved position
                d_cp_moved = true;

                // Start RG
                // TODO: Do we really need to reset everything? I would prefer it, because
                // in Amateur Radio, signal loss and station change happen frequently.
                d_initial_acquired = false;

                d_samp_phase = 0;
                d_cp_moved = true;
                d_symbol_acq = false;
                d_freq_offset_acq = false;

                d_current_symbol = 0;
                d_symbol_correct_count = 0;

                d_freq_offset_agree_count = 0;
                d_total_freq_error = 0;
                d_fine_freq = 0.0;
                d_coarse_freq = 0.0;
                d_freq_offset = 0;
                d_samp_inc = 1.0; // from ISDB-T block
                d_est_delta = 0;  // from ISDB-T block

                d_phaseinc = 0;
                d_phase = 0;
                // end RG
            }
        }

        if (d_cp_found) {
            // Safe-margin. Using a too adjusted CP position may result in taking samples
            // from the NEXT OFDM symbol. It is better to stay on the safe-side (plus, 10
            // samples is nothing in this context).
            d_cp_start_offset = -10;

            int low = d_cp_start + d_cp_start_offset - d_fft_length + 1;

            if (d_interpolate) {
                // I interpolate the signal with the estimated sampling clock error.
                // The filter used as interpolator has non-causal output (why is beyond my
                // understading). This -3 solves this issue. TODO: why does this happen?
                // Better solution?
                required_for_interpolation =
                    interpolate_input(&in[d_consumed + low - 3], &d_interpolated[0]);

                // I derotate the signal with the estimated frequency error.
                derotate(&d_interpolated[0], d_fft_calculator.get_inbuf());
            } else {
                derotate(&in[d_consumed + low], d_fft_calculator.get_inbuf());
            }

            // I (naturally) calculate the FFT.
            calculate_fft(&d_postfft[0]);

            // Calculate the integer frequency error (only when not already acquired)
            int current_freq_offset = 0;
            if (!d_freq_offset_acq) {
                current_freq_offset = estimate_integer_freq_offset(&d_postfft[0]);
            }
            // Since I'm compensating it in the derotator I have to add it
            d_freq_offset += current_freq_offset;

            // correct the integer frequency offset (point to the shifted position)
            d_integer_freq_derotated =
                &d_postfft[0] + current_freq_offset + d_zeros_on_left;

            // Estimate the current symbol index.
            // Only re-estimate it when the symbol was not acquired.
            d_previous_symbol = d_current_symbol;
            if (d_symbol_acq) {
                d_current_symbol = (d_current_symbol + 1) % 4;
            } else {
                d_current_symbol = estimate_symbol_index(d_integer_freq_derotated);
            }
            send_symbol_index_and_resync(i);

            // RG: I don't understand why in the original code previous symbol and current
            // symbol are swapped and not only the previous symbol is stored but
            // nevertheless it seems to work. In the original code pointers are used but
            // this does not work with volk::vector so I need to swap the contents.
            // Today's PCs seem to be fast enough for that ;-)

            // I keep the last symbol for fine-synchro.
            // gr_complex* aux = d_previous_channel_gain;
            // d_previous_channel_gain = d_channel_gain;
            // d_channel_gain = aux;
            d_channel_gain.swap(d_previous_channel_gain);

            // I calculate the channel taps at the SPs...
            calculate_channel_taps_sp(
                d_integer_freq_derotated, d_current_symbol, &d_channel_gain[0]);

            // and interpolate in the rest of the carriers.
            linearly_estimate_channel_taps(d_current_symbol, &d_channel_gain[0]);

            // Equalization is applied.

            // I now perform a rather indirect complex division with VOLK (plus, I tried
            // to minimize the usage of auxilary variables)
            // TODO a new VOLK kernel that makes complex division? Already implemented.
            // However, I'll use what follows instead for compatibility reasons. Uncomment
            // the next line instead when its usage is widespread.
            // volk_32fc_x2_divide_32fc(&out[i * d_active_carriers_size],
            //                         d_integer_freq_derotated,
            //                         d_channel_gain,
            //                         d_active_carriers_size);
            volk_32fc_x2_multiply_conjugate_32fc(&out[i * d_num_carriers],
                                                 d_integer_freq_derotated,
                                                 &d_channel_gain[0],
                                                 d_num_carriers);
            volk_32fc_magnitude_squared_32f(
                &d_channel_gain_mag_sq[0], &d_channel_gain[0], d_num_carriers);
            volk_32f_x2_divide_32f(&d_channel_gain_mag_sq[0],
                                   &d_ones[0],
                                   &d_channel_gain_mag_sq[0],
                                   d_num_carriers);
            volk_32fc_32f_multiply_32fc(&out[i * d_num_carriers],
                                        &out[i * d_num_carriers],
                                        &d_channel_gain_mag_sq[0],
                                        d_num_carriers);
            // Using what follows instead, is actually slower (seems that taking powers is
            // worse than simply dividing).
            // volk_32fc_s32f_power_32fc(d_channel_gain_inv, d_channel_gain, -1.0,
            // d_active_carriers_size);
            // volk_32fc_x2_multiply_32fc(&out[i*d_active_carriers_size],
            // d_integer_freq_derotated, d_channel_gain_inv, d_active_carriers_size);

            if (ch_output_connected) {
                // The channel taps output is connected
                memcpy(&out_channel_gain[i * d_num_carriers],
                       &d_channel_gain[0],
                       d_num_carriers * sizeof(gr_complex));
            }
            if (freq_error_output_connected) {
                out_freq_error[i] =
                    d_total_freq_error / (2 * static_cast<float>(GR_M_PI));
            }
            if (samp_error_output_connected) {
                out_samp_error[i] = d_est_delta;
            }

            // This is the value used for derotation. Attention should be payed, since
            // it includes coarse frequency, fine frequency AND integer frequency offset.
            d_total_freq_error = d_fine_freq + d_coarse_freq +
                                 static_cast<float>(GR_M_PI) * 2 * d_freq_offset;

            // I update the fine timing and frequency estimations.
            estimate_fine_synchro(&d_channel_gain[0], &d_previous_channel_gain[0]);

            d_to_output += 1;
        } else {
            // If we are here it means that we could not find the CP in the current
            // observation period. Signal it downstream, consume some samples, exit and
            // hope for the best in the next call to general_work().

            //  Send sync_start downstream
            send_sync_start();
            d_initial_acquired = false;

            d_samp_phase = 0;
            d_cp_moved = true;
            d_symbol_acq = false;
            d_freq_offset_acq = false;

            d_current_symbol = 0;
            d_symbol_correct_count = 0;

            d_freq_offset_agree_count = 0;
            d_total_freq_error = 0;
            d_fine_freq = 0.0;
            d_coarse_freq = 0.0;
            d_freq_offset = 0;
            d_samp_inc = 1.0; // from ISDB-T block
            d_est_delta = 0;  // from ISDB-T block

            d_phaseinc = 0;
            d_phase = 0;

            // Consume 1/8 of the data and restart so that we'll not end up with the same
            // situation (in the case when the CP was in a weird position, like too near
            // to the border). This will prevent peak_detect from not detecting anything.
            d_consumed += (d_cp_length + d_fft_length) / 8;
            // Tell the runtime system how many input items we have consumed on
            // each input stream.
            consume_each(d_consumed);
            // Tell the runtime system how many output items we have produced.
            return (d_to_output);
        }
        d_consumed += required_for_interpolation;

        int delta_pos = required_for_interpolation - (d_fft_length + d_cp_length);
        d_cp_moved = delta_pos != 0;
    }

    // Tell the runtime system how many input items we have consumed on
    // each input stream.
    consume_each(d_consumed);

    // Tell the runtime system how many output items we have produced.
    return d_to_output;
}

} /* namespace dl5eu */
} /* namespace gr */
